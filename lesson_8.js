/* Не выполняя код, ответить, что выведет браузер и почему: */

if (!("a" in window)) {
    var a = 1;
}
alert(a);

/* В браузерах глобальные функции и переменные, объявленные с помощью var, 
автоматически становятся свойствами глобального объекта. Так как  переменной a 
значение присваивается только в том случае, если её нет в объекте window, 
а она там есть, получается, что код выводит undefined. Если бы использовалось 
ключевое слово let, код выдал бы ошибку*/



var b = function a(x) {
    x && a(--x);
};
alert(a);

/* Код выдаст ошибку, так как переменной с именем a не существует, а есть только
переменная с именем b, в которой находится функция. Если функция определена с 
помощью функции-выражения (function expression), её имя доступно только внутри 
самой функции.*/



function a(x) {
    return x * 2;
}
var a;
alert(a);

/* Код вернет описание функции, так как объявление функции имеет приоритет над
объявлением переменной, поэтому переменная a определяется при объявлении
 функции, и в дальнейшем её значение не меняется*/


function b(x, y, a) {
    arguments[2] = 10;
    alert(a);
}
b(1, 2, 3);


/* Внутри функции происходит изменение значения третьего по порядку аргумента,
поэтому он вместо 3 становится равен 10, и функция выводит 10. Доступ ко всем 
аргументам функции можно получить используя псевдо-массив arguments.
В старом стандарте JavaScript псевдо-массив arguments и переменные-параметры 
ссылаются на одни и те же значения. В результате изменения arguments влияют 
на параметры и наоборот. В новом стандарте (при использовании "use strict") 
такого бы не произошло, а осталось бы = 3 */

function a() {
    alert(this);
}
a.call(null);

/*Результатом в браузере будет "[object Window]"
В современном стандарте call/apply передают this «как есть», в таком случае 
(при использовании "use strict") результатом был бы null
А в старом, без use strict, при указании первого аргумента null или undefined 
в call/apply, функция получает this = window */